* use terra's GP regression for detrending, rather than legendre series sums.

> not terra's imple,entatio, but the scikit learn implementation seems pretty
> slow. This definitely could be a useful method though (just more complicated
> than necessary)

* make completeness maps (vs Î´_inj, P_inj, P_EB, rms_biased)

> Done. We need ~4x better noise RMS across all LCs.
> Note (per discussion w/ Fei Dai) a better metric than RMS is CDPP over 6hrs.
> This is like roughly "pass a 6 hour window over LC. for all the points in
> each window, compute variance. Then compute the mean of the variances".

* check normalization is being done thru *DIVISION* by mean (not subtraction),
b/c division preservers relative fluxes..

> Done

* Possible to high/loss pass filter at ~<2x EB period? (Read Feigelson text & see)

> Butterworth filters are the idea, and they ruin transits (smoothing is too
> powerful, timescales too close -- the sinc(f) of a FT'd box function does not
> play well with Butterworth).

* Email Johan for his code -- more general fourier approach (more expensive
  too).

> Emailed. Tried implemented it too -- works shittily. But my implementation
> may have bugs.

* iteratively whiten via either:
    1. if next bst period is a harmonic of original signal, subtract off new
    legendre fit
    2. scipy.signal: genereate filters based on Fourier representation of LC,
    including all the harmonics, and pass them thru
> barebones implementation done. 

* Iteratively whiten out more frequencies. (Say ~few more) (Nb. this depends on
  whether there are strong periodicities in current redtrended residuals, or
  whether the spot-movement is "pseudo-periodic")

* on iterwhiten plots: add ylabel including iternum (like what's already in fname)
  also show npts & legendredeg on phased fit.

* cut out data within "0.5d regions" of gaps (defined by
    >0.5day space btwn points)
  -> nb. lcmath.find_lc_timegroups(fsaptimes, mingap=mingap) is most relevant.
  -> implement as trim_near_gaps. 
  (nb. does not require "stitching" to get full LC... you can do just over 
  quarters still)

* revise period bounds of iterative whitening to [0.05day, 5xP_EB]

* debug why inum never goes above 2
  > bug: badly formed bracket -> a sqrt was trying to do a negative number and
  nanning

* during iterative whiten, add f(t) filter with mid-level legendre series fit
  (to time-groups), then subsequent subtraction for >~10day trend removal. 

* clear out the TODOs and FIXMEs from the iterative whitening implementation.

* in phase, it does not make sense to limit by npts. It should be the the
  number of phases being folded over! e.g., even w/ 1k points, at a 0.5 day fold
  you have 40 phases. The number of phases should be the determining factor, not
  the number of points (will help with Q0 and Q17)

* revise legendredeg(npts) function... maybe allow sharper even w/ fewer pts, as
  long as within "safe" period bounds (<5x P_EB).

* Similarly, fine-tune the sigma clipping based on the actual RMS across a
    quarter. **If (once detrended+whitened) it's very small, we must allow
    bigger dips (w/out clipping them).**

* lcmath.find_lc_timegroups -- basically an implementation of astrokep's
 find_lightcurve_gaps, already done.

- hard cut on escaping once RMS<0.05% threshold.

* complete tests/assessment of how well iterative whitening looks like it's 
  working (see e.g., how far down you can push in the rms floor)
  (also note that many sharp features seem to fail)

##########
Mon 20 Mar 2017 02:55:24 PM EDT
* add find_dip with iterative whitening 
