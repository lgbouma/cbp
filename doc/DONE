* use terra's GP regression for detrending, rather than legendre series sums.

> not terra's imple,entatio, but the scikit learn implementation seems pretty
> slow. This definitely could be a useful method though (just more complicated
> than necessary)

* make completeness maps (vs Î´_inj, P_inj, P_EB, rms_biased)

> Done. We need ~4x better noise RMS across all LCs.
> Note (per discussion w/ Fei Dai) a better metric than RMS is CDPP over 6hrs.
> This is like roughly "pass a 6 hour window over LC. for all the points in
> each window, compute variance. Then compute the mean of the variances".

* check normalization is being done thru *DIVISION* by mean (not subtraction),
b/c division preservers relative fluxes..

> Done

* Possible to high/loss pass filter at ~<2x EB period? (Read Feigelson text & see)

> Butterworth filters are the idea, and they ruin transits (smoothing is too
> powerful, timescales too close -- the sinc(f) of a FT'd box function does not
> play well with Butterworth).

* Email Johan for his code -- more general fourier approach (more expensive
  too).

> Emailed. Tried implemented it too -- works shittily. But my implementation
> may have bugs.

* iteratively whiten via either:
    1. if next bst period is a harmonic of original signal, subtract off new
    legendre fit
    2. scipy.signal: genereate filters based on Fourier representation of LC,
    including all the harmonics, and pass them thru
> barebones implementation done. 

* Iteratively whiten out more frequencies. (Say ~few more) (Nb. this depends on
  whether there are strong periodicities in current redtrended residuals, or
  whether the spot-movement is "pseudo-periodic")

* on iterwhiten plots: add ylabel including iternum (like what's already in fname)
  also show npts & legendredeg on phased fit.

* cut out data within "0.5d regions" of gaps (defined by
    >0.5day space btwn points)
  -> nb. lcmath.find_lc_timegroups(fsaptimes, mingap=mingap) is most relevant.
  -> implement as trim_near_gaps. 
  (nb. does not require "stitching" to get full LC... you can do just over 
  quarters still)

* revise period bounds of iterative whitening to [0.05day, 5xP_EB]

* debug why inum never goes above 2
  > bug: badly formed bracket -> a sqrt was trying to do a negative number and
  nanning

* during iterative whiten, add f(t) filter with mid-level legendre series fit
  (to time-groups), then subsequent subtraction for >~10day trend removal. 

* clear out the TODOs and FIXMEs from the iterative whitening implementation.

* in phase, it does not make sense to limit by npts. It should be the the
  number of phases being folded over! e.g., even w/ 1k points, at a 0.5 day fold
  you have 40 phases. The number of phases should be the determining factor, not
  the number of points (will help with Q0 and Q17)

* revise legendredeg(npts) function... maybe allow sharper even w/ fewer pts, as
  long as within "safe" period bounds (<5x P_EB).

* Similarly, fine-tune the sigma clipping based on the actual RMS across a
    quarter. **If (once detrended+whitened) it's very small, we must allow
    bigger dips (w/out clipping them).**

* lcmath.find_lc_timegroups -- basically an implementation of astrokep's
 find_lightcurve_gaps, already done.

- hard cut on escaping once RMS<0.05% threshold.

* complete tests/assessment of how well iterative whitening looks like it's 
  working (see e.g., how far down you can push in the rms floor)
  (also note that many sharp features seem to fail)

* add find_dip with iterative whitening 

* in recovery, check correct periods, off by 1 orbit in time. (this is b/c 
  min time gets cut. Implement a workaround at some stage, e.g., after
  BLS!)

* reassess completeness (coarse level).
  Result: it's complete enough for ~4Re, ~4-80P_EB period CBPs. (like 50%)

Sun 26 Mar 2017 09:52:32 AM EDT

* Fix injrecovresult_analysis to open whatever pickles are there and use THOSE,
rather than go thru whatever random number seeds are necessary.

> implemented. But now make it a cmd line arg with parser.
> done. we're finally using argparse, and i got the chance to refactor
  run_inj_recov to be wayyy clearer.

Identify highest significance dips in search:
########## 

X compute CDPP 6hr.

> after reading Christiansen's 2012 and Jenkins 2010 (CDPP) description...
this is not worth the effort. They're using some kind of wavelet matched
filter approach, and describe CDPP as a thing that only really can be computed
*sticking to their exact pipeline approach*. better idea is to just stick with
the RMS. 

X make plot to compare success0 and success1 RMSs (once success1 has correct
injrecovresults)

> yes, iterative whitening did help (duh). previously (single iteration) ~20%
of EBs had biased RMS less than 1e-3. with iterative withening, it's ~70%.

* get BLS depth (to compute depth/RMS)

* log recovered BLS depth in the csv files too

* plot: (recovered depth / injected depth) vs RMS (or whatever quantity).

* why do we have negative transit depths recovered?
> because BLS can find them. In a smaller number of cases (~10 of the ~540),
the whitening subtracts the planet signal (notably if it's very big). But the
point is that BLS has no prior for wanting positive depth transits. So 75 of
540 injection recovery tests wind up with NEGATIVE depths (mostly because of
stellar variability producing some kind of coherent signal in the periodogram).
It seems like it would be smarter to have some prior to avoid this.
Like "if the BLS depth for this proposed period is negative... downweight the
power of this period!!"
(Note e.g., the case dipsearchplot/inj/10090246_sapdipsearch_inj_0.00125.png:
primary period gives such a negative depth (i.e. a brightening). But there the
4th period gives the correct dip)

* does the 4th period get the correct recovered depth?
> yes. nthbestperiod gets serialdict, which contains the depths.


